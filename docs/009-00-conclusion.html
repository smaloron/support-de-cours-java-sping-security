<!DOCTYPE html SYSTEM "about:legacy-compat">
<html lang="en-US" data-preset="contrast" data-primary-color="#307FFF"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta charset="UTF-8"><meta name="robots" content="noindex"><meta name="built-on" content="2025-07-02T15:16:03.700912"><title>Conclusion | Spring Security</title><script type="application/json" id="virtual-toc-data">[{"id":"conseils-et-bonnes-pratiques","level":0,"title":"Conseils et Bonnes Pratiques","anchor":"#conseils-et-bonnes-pratiques"},{"id":"conclusion-g-n-rale","level":0,"title":"Conclusion générale","anchor":"#conclusion-g-n-rale"},{"id":"corrections-des-auto-valuations","level":0,"title":"Cliquez pour voir toutes les corrections","anchor":"#corrections-des-auto-valuations"}]</script><script type="application/json" id="topic-shortcuts"></script><link href="https://resources.jetbrains.com/writerside/apidoc/6.22.0-b776/app.css" rel="stylesheet"><meta name="msapplication-TileColor" content="#000000"><link rel="apple-touch-icon" sizes="180x180" href="https://jetbrains.com/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="https://jetbrains.com/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="https://jetbrains.com/favicon-16x16.png"><meta name="msapplication-TileImage" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-144x144.png"><meta name="msapplication-square70x70logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-70x70.png"><meta name="msapplication-square150x150logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-150x150.png"><meta name="msapplication-wide310x150logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-310x150.png"><meta name="msapplication-square310x310logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-310x310.png"><meta name="image" content=""><!-- Open Graph --><meta property="og:title" content="Conclusion | Spring Security"><meta property="og:description" content=""><meta property="og:image" content=""><meta property="og:site_name" content="Spring Security Help"><meta property="og:type" content="website"><meta property="og:locale" content="en_US"><meta property="og:url" content="writerside-documentation/009-00-conclusion.html"><!-- End Open Graph --><!-- Twitter Card --><meta name="twitter:card" content="summary_large_image"><meta name="twitter:site" content=""><meta name="twitter:title" content="Conclusion | Spring Security"><meta name="twitter:description" content=""><meta name="twitter:creator" content=""><meta name="twitter:image:src" content=""><!-- End Twitter Card --><!-- Schema.org WebPage --><script type="application/ld+json">{
    "@context": "http://schema.org",
    "@type": "WebPage",
    "@id": "writerside-documentation/009-00-conclusion.html#webpage",
    "url": "writerside-documentation/009-00-conclusion.html",
    "name": "Conclusion | Spring Security",
    "description": "",
    "image": "",
    "inLanguage":"en-US"
}</script><!-- End Schema.org --><!-- Schema.org WebSite --><script type="application/ld+json">{
    "@type": "WebSite",
    "@id": "writerside-documentation/#website",
    "url": "writerside-documentation/",
    "name": "Spring Security Help"
}</script><!-- End Schema.org --></head><body data-id="009-00-conclusion" data-main-title="Conclusion" data-article-props="{&quot;seeAlsoStyle&quot;:&quot;links&quot;}" data-template="article" data-breadcrumbs=""><div class="wrapper"><main class="panel _main"><header class="panel__header"><div class="container"><h3>Spring Security  Help</h3><div class="panel-trigger"></div></div></header><section class="panel__content"><div class="container"><article class="article" data-shortcut-switcher="inactive"><h1 data-toc="009-00-conclusion" id="009-00-conclusion.md">Conclusion</h1><section class="chapter"><h2 id="conseils-et-bonnes-pratiques" data-toc="conseils-et-bonnes-pratiques">Conseils et Bonnes Pratiques</h2><section class="chapter"><h3 id="introduction" data-toc="introduction">Introduction</h3><p id="-23riyj_16">La ma&icirc;trise d'un outil comme Spring Security ne s'arr&ecirc;te pas &agrave; la connaissance de ses fonctionnalit&eacute;s. Elle r&eacute;side surtout dans la capacit&eacute; &agrave; les utiliser judicieusement. Un couteau suisse est un outil fantastique, mais on ne l'utilise pas pour planter un clou si on a un marteau &agrave; disposition.</p><p id="-23riyj_17">Cette section est votre &quot;bo&icirc;te &agrave; outils mentale&quot;. Elle regroupe des conseils, des r&eacute;flexions et des bonnes pratiques accumul&eacute;s par la communaut&eacute; au fil des ans. Ce ne sont pas des r&egrave;gles absolutes, mais des guides qui vous aideront &agrave; prendre des d&eacute;cisions &eacute;clair&eacute;es, &agrave; &eacute;crire un code plus s&ucirc;r, plus propre et plus maintenable. Gardez-les &agrave; l'esprit lorsque vous concevrez l'architecture de s&eacute;curit&eacute; de vos futures applications.</p></section><section class="chapter"><h3 id="1-penser-secure-by-default" data-toc="1-penser-secure-by-default">1. Penser &quot;Secure by Default&quot;</h3><p id="-23riyj_18">Le principe le plus important. Configurez toujours votre s&eacute;curit&eacute; de la mani&egrave;re la plus restrictive possible au d&eacute;part, puis ouvrez les acc&egrave;s au cas par cas.</p><ul class="list _bullet" id="-23riyj_19"><li class="list__item" id="-23riyj_20"><p id="-23riyj_21"><span class="control" id="-23riyj_22">Pratique concr&egrave;te</span>: Terminez toujours votre cha&icirc;ne de configuration <code class="code" id="-23riyj_23">authorizeHttpRequests</code> par <code class="code" id="-23riyj_24">.anyRequest().authenticated()</code> ou, encore mieux, <code class="code" id="-23riyj_25">.anyRequest().denyAll()</code>. Cela vous force &agrave; autoriser explicitement chaque nouvel endpoint, &eacute;vitant ainsi d'exposer accidentellement une nouvelle fonctionnalit&eacute;.</p></li></ul></section><section class="chapter"><h3 id="2-ne-jamais-stocker-de-secrets-en-clair" data-toc="2-ne-jamais-stocker-de-secrets-en-clair">2. Ne Jamais Stocker de Secrets en Clair</h3><p id="-23riyj_26">C'est la r&egrave;gle d'or. Un secret est une information qui, si elle est compromise, peut mettre en p&eacute;ril votre syst&egrave;me (mots de passe, cl&eacute;s d'API, cl&eacute;s de signature JWT, secrets client OAuth).</p><ul class="list _bullet" id="-23riyj_27"><li class="list__item" id="-23riyj_28"><p id="-23riyj_30"><span class="control" id="-23riyj_31">Mots de passe</span>: Utilisez toujours un <code class="code" id="-23riyj_32">PasswordEncoder</code> adaptatif et fort comme <code class="code" id="-23riyj_33">BCryptPasswordEncoder</code>. Jamais de MD5, SHA-1, ou de stockage en clair.</p></li><li class="list__item" id="-23riyj_29"><p id="-23riyj_34"><span class="control" id="-23riyj_36">Autres secrets (cl&eacute;s, etc.)</span>:</p><ul class="list _bullet" id="-23riyj_35"><li class="list__item" id="-23riyj_37"><p id="-23riyj_39"><span class="control" id="-23riyj_40">En d&eacute;veloppement</span>: Vous pouvez les mettre dans <code class="code" id="-23riyj_41">application.properties</code>, mais ajoutez ce fichier &agrave; votre <code class="code" id="-23riyj_42">.gitignore</code>! Utilisez un fichier <code class="code" id="-23riyj_43">application-dev.properties</code> pour les secrets locaux et activez le profil <code class="code" id="-23riyj_44">dev</code>.</p></li><li class="list__item" id="-23riyj_38"><p id="-23riyj_45"><span class="control" id="-23riyj_46">En production</span>: La meilleure pratique est d'utiliser des <span class="control" id="-23riyj_47">variables d'environnement</span> ou un <span class="control" id="-23riyj_48">gestionnaire de secrets</span> (comme HashiCorp Vault, AWS Secrets Manager, Azure Key Vault). Spring Boot peut lire les configurations depuis ces sources.</p></li></ul></li></ul></section><section class="chapter"><h3 id="3-privil-gier-la-s-curit-au-niveau-des-m-thodes-pour-la-logique-m-tier" data-toc="3-privil-gier-la-s-curit-au-niveau-des-m-thodes-pour-la-logique-m-tier">3. Privil&eacute;gier la S&eacute;curit&eacute; au niveau des M&eacute;thodes pour la Logique m&eacute;tier</h3><p id="-23riyj_49">La s&eacute;curit&eacute; par URL est une excellente premi&egrave;re ligne de d&eacute;fense, mais elle est fragile. Si un d&eacute;veloppeur d&eacute;place un endpoint d'un contr&ocirc;leur &agrave; un autre, la r&egrave;gle peut ne plus s'appliquer.</p><ul class="list _bullet" id="-23riyj_50"><li class="list__item" id="-23riyj_51"><p id="-23riyj_52"><span class="control" id="-23riyj_53">Pratique concr&egrave;te</span>: Utilisez <code class="code" id="-23riyj_54">http.authorizeHttpRequests</code> pour les r&egrave;gles de haut niveau (ex: <code class="code" id="-23riyj_55">/admin/**</code> requiert <code class="code" id="-23riyj_56">ROLE_ADMIN</code>). Pour la logique m&eacute;tier fine (&quot;seul le propri&eacute;taire du projet peut le modifier&quot;), utilisez <code class="code" id="-23riyj_57">@PreAuthorize</code> directement sur vos m&eacute;thodes de <span class="control" id="-23riyj_58">service</span>. Placer la s&eacute;curit&eacute; au plus pr&egrave;s de la donn&eacute;e est plus robuste.</p></li></ul></section><section class="chapter"><h3 id="4-choisir-la-bonne-strat-gie-d-authentification" data-toc="4-choisir-la-bonne-strat-gie-d-authentification">4. Choisir la Bonne Strat&eacute;gie d'Authentification</h3><p id="-23riyj_59">Ne tombez pas dans le pi&egrave;ge du &quot;tout JWT&quot;. Chaque strat&eacute;gie a sa place.</p><ul class="list _bullet" id="-23riyj_60"><li class="list__item" id="-23riyj_61"><p id="-23riyj_64"><span class="control" id="-23riyj_65">Application web monolithique (ex: servie avec Thymeleaf)</span>: L'authentification par <span class="control" id="-23riyj_66">session + cookies</span> est souvent plus simple, plus s&ucirc;re (cookies <code class="code" id="-23riyj_67">HttpOnly</code>) et parfaitement adapt&eacute;e. La protection CSRF est essentielle ici.</p></li><li class="list__item" id="-23riyj_62"><p id="-23riyj_68"><span class="control" id="-23riyj_70">Single Page Application (SPA) + API Backend</span>:</p><ul class="list _bullet" id="-23riyj_69"><li class="list__item" id="-23riyj_71"><p id="-23riyj_73">Si la SPA et le backend sont sur le <span class="control" id="-23riyj_74">m&ecirc;me domaine</span>, l'authentification par session avec le <code class="code" id="-23riyj_75">CookieCsrfTokenRepository</code> est une excellente option, tr&egrave;s s&eacute;curis&eacute;e.</p></li><li class="list__item" id="-23riyj_72"><p id="-23riyj_76">Si la SPA et le backend sont sur des <span class="control" id="-23riyj_77">domaines diff&eacute;rents (CORS)</span>, ou si l'API doit &ecirc;tre consomm&eacute;e par des applications mobiles, <span class="control" id="-23riyj_78">JWT</span> est la solution standard.</p></li></ul></li><li class="list__item" id="-23riyj_63"><p id="-23riyj_79"><span class="control" id="-23riyj_80">Microservices</span>: <span class="control" id="-23riyj_81">JWT</span> ou <span class="control" id="-23riyj_82">OAuth 2.0 (introspection)</span> sont les standards. Les tokens permettent aux services de se valider les uns les autres sans &eacute;tat partag&eacute;.</p></li></ul></section><section class="chapter"><h3 id="5-utiliser-les-r-les-et-les-permissions-bon-escient" data-toc="5-utiliser-les-r-les-et-les-permissions-bon-escient">5. Utiliser les R&ocirc;les et les Permissions &agrave; bon escient</h3><ul class="list _bullet" id="-23riyj_83"><li class="list__item" id="-23riyj_86"><p id="-23riyj_88"><span class="control" id="-23riyj_89">R&ocirc;les</span>: Qui est l'utilisateur ? (<code class="code" id="-23riyj_90">ADMIN</code>, <code class="code" id="-23riyj_91">MANAGER</code>, <code class="code" id="-23riyj_92">READER</code>).</p></li><li class="list__item" id="-23riyj_87"><p id="-23riyj_93"><span class="control" id="-23riyj_94">Permissions (Authorities)</span>: Que peut faire l'utilisateur ? (<code class="code" id="-23riyj_95">project:read</code>, <code class="code" id="-23riyj_96">project:write</code>, <code class="code" id="-23riyj_97">user:delete</code>).</p></li></ul><p id="-23riyj_84">Pour les applications simples, les r&ocirc;les peuvent suffire. Pour les applications complexes, une approche bas&eacute;e sur les permissions est beaucoup plus flexible. Un r&ocirc;le devient alors un simple groupe de permissions. Votre code doit v&eacute;rifier les permissions, pas les r&ocirc;les.</p><ul class="list _bullet" id="-23riyj_85"><li class="list__item" id="-23riyj_98"><p id="-23riyj_100"><span class="control" id="-23riyj_101">Mauvais</span>: <code class="code" id="-23riyj_102">@PreAuthorize(&quot;hasRole('ADMIN') or hasRole('PROJECT_LEAD')&quot;)</code></p></li><li class="list__item" id="-23riyj_99"><p id="-23riyj_103"><span class="control" id="-23riyj_104">Bon</span>: <code class="code" id="-23riyj_105">@PreAuthorize(&quot;hasAuthority('project:delete')&quot;)</code> Demain, si vous ajoutez un r&ocirc;le <code class="code" id="-23riyj_106">SUPER_USER</code> qui doit pouvoir supprimer des projets, vous n'aurez qu'&agrave; lui donner la permission, sans modifier votre code.</p></li></ul></section><section class="chapter"><h3 id="6-minimiser-la-surface-d-attaque" data-toc="6-minimiser-la-surface-d-attaque">6. Minimiser la surface d'attaque</h3><ul class="list _bullet" id="-23riyj_107"><li class="list__item" id="-23riyj_108"><p id="-23riyj_112"><span class="control" id="-23riyj_113">D&eacute;sactivez les fonctionnalit&eacute;s inutiles</span>: Si vous n'utilisez pas <code class="code" id="-23riyj_114">rememberMe()</code>, ne le configurez pas.</p></li><li class="list__item" id="-23riyj_109"><p id="-23riyj_115"><span class="control" id="-23riyj_116">Validez toutes les entr&eacute;es</span>: Utilisez les annotations de validation (<code class="code" id="-23riyj_117">@Valid</code>, <code class="code" id="-23riyj_118">@NotNull</code>, etc.) sur vos DTOs. C'est votre premi&egrave;re d&eacute;fense contre les injections.</p></li><li class="list__item" id="-23riyj_110"><p id="-23riyj_119"><span class="control" id="-23riyj_120">Ne pas exposer d'informations sensibles dans les logs</span>: Faites attention &agrave; ne pas logger de mots de passe, de tokens ou de donn&eacute;es personnelles. Configurez le niveau de log de Spring Security en <code class="code" id="-23riyj_121">INFO</code> ou <code class="code" id="-23riyj_122">WARN</code> en production.</p></li><li class="list__item" id="-23riyj_111"><p id="-23riyj_123"><span class="control" id="-23riyj_124">G&eacute;rer les d&eacute;pendances</span>: Utilisez des outils comme le <code class="code" id="-23riyj_125">dependency-check-maven</code> plugin ou Snyk pour scanner vos d&eacute;pendances &agrave; la recherche de vuln&eacute;rabilit&eacute;s connues (CVE). Une vieille version d'une biblioth&egrave;que peut contenir une faille critique.</p></li></ul></section><section class="chapter"><h3 id="7-comprendre-les-logs" data-toc="7-comprendre-les-logs">7. Comprendre les Logs</h3><p id="-23riyj_126">Les logs de Spring Security peuvent &ecirc;tre verbeux, mais ils sont une mine d'or pour le d&eacute;bogage. Si une connexion &eacute;choue ou qu'un acc&egrave;s est refus&eacute;, passez le niveau de log en <code class="code" id="-23riyj_127">DEBUG</code> (<code class="code" id="-23riyj_128">logging.level.org.springframework.security=DEBUG</code> dans <code class="code" id="-23riyj_129">application.properties</code>) et rejouez le sc&eacute;nario. Vous verrez exactement quel filtre a pris quelle d&eacute;cision et pourquoi.</p></section><section class="chapter"><h3 id="8-s-parer-la-configuration" data-toc="8-s-parer-la-configuration">8. S&eacute;parer la Configuration</h3><p id="-23riyj_130">Pour les projets complexes, ne mettez pas toute votre configuration de s&eacute;curit&eacute; dans une seule classe. Vous pouvez avoir plusieurs <code class="code" id="-23riyj_132">SecurityFilterChain</code> beans, chacun avec un <code class="code" id="-23riyj_133">@Order</code> diff&eacute;rent, pour g&eacute;rer diff&eacute;rentes parties de votre application (ex: une cha&icirc;ne pour l'API REST, une autre pour le site web d'admin).</p><div class="code-block" data-lang="java">
@Bean
@Order(1)
public SecurityFilterChain apiSecurityFilterChain(HttpSecurity http) {
    // Configuration pour /api/** avec JWT
}

@Bean
@Order(2)
public SecurityFilterChain webSecurityFilterChain(HttpSecurity http) {
    // Configuration pour /admin/** avec formLogin
}
</div></section><section class="chapter"><h3 id="conclusion" data-toc="conclusion">Conclusion</h3><p id="-23riyj_134">La s&eacute;curit&eacute; n'est pas un produit que l'on ach&egrave;te, ni une fonctionnalit&eacute; que l'on ajoute &agrave; la fin. C'est un <span class="control" id="-23riyj_137">processus</span> et une <span class="control" id="-23riyj_138">mentalit&eacute;</span>. En int&eacute;grant ces bonnes pratiques dans votre routine de d&eacute;veloppement, vous ne ferez pas que construire des applications qui fonctionnent, vous construirez des forteresses digitales robustes et dignes de confiance.</p><p id="-23riyj_135">Le plus grand conseil est peut-&ecirc;tre le plus simple : <span class="control" id="-23riyj_139">soyez curieux et restez humble</span>. Le paysage des menaces &eacute;volue constamment. Continuez &agrave; vous informer, lisez les blogs de s&eacute;curit&eacute;, suivez les publications de l'OWASP. Votre vigilance est le rempart le plus efficace.</p></section></section><section class="chapter"><h2 id="conclusion-g-n-rale" data-toc="conclusion-g-n-rale">Conclusion g&eacute;n&eacute;rale</h2><p id="-23riyj_140">Nous voici au terme de notre parcours. Prenez un instant pour regarder le chemin parcouru. Vous avez d&eacute;but&eacute; avec les concepts fondamentaux de la s&eacute;curit&eacute; web, et vous terminez avec la capacit&eacute; de mettre en &oelig;uvre des sch&eacute;mas d'authentification et d'autorisation complexes et modernes. C'est une mont&eacute;e en comp&eacute;tence spectaculaire et vous pouvez en &ecirc;tre fier.</p><section class="chapter"><h3 id="ce-que-vous-avez-appris" data-toc="ce-que-vous-avez-appris">Ce que vous avez appris</h3><p id="-23riyj_144">Au cours de ces modules, vous avez transform&eacute; une application ouverte &agrave; tous les vents en une forteresse s&eacute;curis&eacute;e.</p><ul class="list _bullet" id="-23riyj_145"><li class="list__item" id="-23riyj_146"><p id="-23riyj_152">Vous avez appris le langage de la s&eacute;curit&eacute;, en distinguant <span class="control" id="-23riyj_153">l'authentification</span> de <span class="control" id="-23riyj_154">l'autorisation</span>, et en identifiant les menaces courantes comme <span class="control" id="-23riyj_155">XSS</span> et <span class="control" id="-23riyj_156">CSRF</span>.</p></li><li class="list__item" id="-23riyj_147"><p id="-23riyj_157">Vous avez ma&icirc;tris&eacute; la <span class="control" id="-23riyj_158">configuration de base</span> de Spring Security, en passant d'une simple ligne dans un fichier de propri&eacute;t&eacute;s &agrave; des classes de configuration Java compl&egrave;tes et expressives.</p></li><li class="list__item" id="-23riyj_148"><p id="-23riyj_159">Vous avez impl&eacute;ment&eacute; une <span class="control" id="-23riyj_160">authentification robuste</span>, d'abord en m&eacute;moire, puis en vous branchant &agrave; une <span class="control" id="-23riyj_161">base de donn&eacute;es</span>, en prenant soin de toujours <span class="control" id="-23riyj_162">hacher les mots de passe</span>.</p></li><li class="list__item" id="-23riyj_149"><p id="-23riyj_163">Vous avez explor&eacute; la <span class="control" id="-23riyj_164">personnalisation avanc&eacute;e</span>, en cr&eacute;ant vos propres logiques d'authentification avec des <code class="code" id="-23riyj_165">AuthenticationProvider</code> et en g&eacute;rant finement les redirections et les erreurs.</p></li><li class="list__item" id="-23riyj_150"><p id="-23riyj_166">Vous vous &ecirc;tes tourn&eacute; vers le futur en ma&icirc;trisant <span class="control" id="-23riyj_167">l'authentification stateless avec les JWT</span>, une comp&eacute;tence indispensable pour le d&eacute;veloppement d'API modernes.</p></li><li class="list__item" id="-23riyj_151"><p id="-23riyj_168">Enfin, vous avez ouvert votre application au monde ext&eacute;rieur en int&eacute;grant la <span class="control" id="-23riyj_169">connexion via des fournisseurs OAuth 2.0 / OIDC</span>, offrant une exp&eacute;rience utilisateur fluide et s&eacute;curis&eacute;e.</p></li></ul></section><section class="chapter"><h3 id="au-del-de-ce-cours-pistes-pour-aller-plus-loin" data-toc="au-del-de-ce-cours-pistes-pour-aller-plus-loin">Au-del&agrave; de ce cours : Pistes pour aller plus loin</h3><p id="-23riyj_170">Le monde de la s&eacute;curit&eacute; est vaste et en constante &eacute;volution. Ce cours vous a donn&eacute; des fondations solides, mais l'aventure ne s'arr&ecirc;te pas l&agrave;. Voici quelques pistes pour continuer &agrave; grandir :</p><ol class="list _decimal" id="-23riyj_171" type="1"><li class="list__item" id="-23riyj_172"><p id="-23riyj_178"><span class="control" id="-23riyj_179">Tests de S&eacute;curit&eacute;</span>: Apprenez &agrave; &eacute;crire des tests pour votre configuration de s&eacute;curit&eacute;. Spring Security fournit un support de test puissant (<code class="code" id="-23riyj_180">@WithMockUser</code>, <code class="code" id="-23riyj_181">MockMvc</code>) pour v&eacute;rifier que vos r&egrave;gles d'autorisation fonctionnent comme pr&eacute;vu.</p></li><li class="list__item" id="-23riyj_173"><p id="-23riyj_182"><span class="control" id="-23riyj_183">S&eacute;curit&eacute; R&eacute;active</span>: Si vous travaillez avec Spring WebFlux, explorez <code class="code" id="-23riyj_184">spring-security-webflux</code> pour s&eacute;curiser vos applications r&eacute;actives.</p></li><li class="list__item" id="-23riyj_174"><p id="-23riyj_185"><span class="control" id="-23riyj_186">OAuth 2.0 - Le C&ocirc;t&eacute; Serveur</span>: Nous avons configur&eacute; notre application en tant que Client. Apprenez &agrave; la configurer en tant que <span class="control" id="-23riyj_187">Serveur d'Autorisation</span> et <span class="control" id="-23riyj_188">Serveur de Ressources</span>. C'est essentiel si vous voulez que votre propre API soit consomm&eacute;e par des applications tierces de mani&egrave;re s&eacute;curis&eacute;e.</p></li><li class="list__item" id="-23riyj_175"><p id="-23riyj_189"><span class="control" id="-23riyj_190">S&eacute;curit&eacute; des Microservices</span>: Plongez dans les patterns de s&eacute;curit&eacute; sp&eacute;cifiques aux microservices : API Gateway (comme Spring Cloud Gateway) qui centralise la s&eacute;curit&eacute;, propagation des tokens, communication inter-services s&eacute;curis&eacute;e (mTLS).</p></li><li class="list__item" id="-23riyj_176"><p id="-23riyj_191"><span class="control" id="-23riyj_192">Gestion Fine des Autorisations (ACL)</span>: Pour des besoins tr&egrave;s granulaires (ex: &quot;cet utilisateur peut &eacute;diter ce document sp&eacute;cifique, mais seulement lire cet autre document&quot;), explorez les <span class="control" id="-23riyj_193">Access Control Lists (ACL)</span> de Spring Security.</p></li><li class="list__item" id="-23riyj_177"><p id="-23riyj_194"><span class="control" id="-23riyj_195">S&eacute;curit&eacute; Cryptographique</span>: Approfondissez vos connaissances en cryptographie : signatures num&eacute;riques, chiffrement sym&eacute;trique vs asym&eacute;trique, gestion des certificats (TLS/SSL).</p></li></ol></section><section class="chapter"><h3 id="le-mot-de-la-fin" data-toc="le-mot-de-la-fin">Le mot de la fin</h3><p id="-23riyj_196">Vous &ecirc;tes d&eacute;sormais bien plus qu'un simple d&eacute;veloppeur. Vous &ecirc;tes un <span class="control" id="-23riyj_200">Concepteur D&eacute;veloppeur d'Application</span> conscient des enjeux de s&eacute;curit&eacute;, capable de construire des applications non seulement fonctionnelles, mais aussi fiables et r&eacute;silientes.</p><p id="-23riyj_197">La s&eacute;curit&eacute; n'est pas un obstacle &agrave; la cr&eacute;ativit&eacute;, mais le cadre qui lui permet de s'&eacute;panouir en toute confiance. Continuez &agrave; construire, &agrave; apprendre et &agrave; s&eacute;curiser. Le web de demain a besoin de d&eacute;veloppeurs comme vous.</p><p id="-23riyj_198">F&eacute;licitations pour votre travail et votre engagement. Le voyage ne fait que commencer !</p></section></section><section class="chapter"><div class="collapse"><div class="collapse__title"><h2 id="corrections-des-auto-valuations" data-toc="corrections-des-auto-valuations">Cliquez pour voir toutes les corrections</h2></div><div class="collapse__content"><section class="chapter"><h3 id="chapitre-1" data-toc="chapitre-1">Chapitre 1</h3><ol class="list _decimal" id="-23riyj_210" type="1"><li class="list__item" id="-23riyj_211"><p id="-23riyj_216"><span class="control" id="-23riyj_217">Question ouverte (Authentification vs Autorisation)</span>: L'authentification, c'est comme montrer sa carte d'identit&eacute; &agrave; l'entr&eacute;e d'un immeuble de bureaux. Le gardien v&eacute;rifie que vous &ecirc;tes bien la personne sur la photo. L'autorisation, c'est le badge que le gardien vous donne apr&egrave;s v&eacute;rification. Ce badge n'ouvre que certaines portes : les &eacute;tages de votre entreprise, mais pas ceux des autres. L'authentification prouve <span class="emphasis" id="-23riyj_218">qui</span> vous &ecirc;tes, l'autorisation d&eacute;finit <span class="emphasis" id="-23riyj_219">ce que vous pouvez faire</span>.</p></li><li class="list__item" id="-23riyj_212"><p id="-23riyj_220"><span class="control" id="-23riyj_221">QCM (XSS)</span>: b) Cross-Site Scripting (XSS)</p></li><li class="list__item" id="-23riyj_213"><p id="-23riyj_222"><span class="control" id="-23riyj_223">QCM (Objectif Spring Security)</span>: c) Offrir un cadre pour l'authentification, l'autorisation et la protection des applications.</p></li><li class="list__item" id="-23riyj_214"><p id="-23riyj_224"><span class="control" id="-23riyj_225">Question ouverte (Mots de passe en clair)</span>: C'est dangereux car en cas de fuite de donn&eacute;es de la base, les mots de passe de tous les utilisateurs sont imm&eacute;diatement expos&eacute;s. Les attaquants peuvent les utiliser pour acc&eacute;der aux comptes de l'application, mais aussi pour tenter de se connecter &agrave; d'autres services (email, banque, etc.) o&ugrave; les utilisateurs ont potentiellement r&eacute;utilis&eacute; le m&ecirc;me mot de passe.</p></li><li class="list__item" id="-23riyj_215"><p id="-23riyj_226"><span class="control" id="-23riyj_227">QCM (Moindre privil&egrave;ge)</span>: c) Le principe de moindre privil&egrave;ge</p></li></ol></section><section class="chapter"><h3 id="chapitre-2" data-toc="chapitre-2">Chapitre 2</h3><ol class="list _decimal" id="-23riyj_228" type="1"><li class="list__item" id="-23riyj_229"><p id="-23riyj_234"><span class="control" id="-23riyj_235">Question ouverte (Secure by Default)</span>: C'est le principe selon lequel un syst&egrave;me doit &ecirc;tre s&eacute;curis&eacute; au maximum dans sa configuration par d&eacute;faut. Spring Security l'applique en prot&eacute;geant tous les endpoints, en activant la protection CSRF, et en exigeant une authentification pour toute l'application d&egrave;s qu'il est ajout&eacute; comme d&eacute;pendance, for&ccedil;ant ainsi le d&eacute;veloppeur &agrave; rel&acirc;cher consciemment la s&eacute;curit&eacute; plut&ocirc;t qu'&agrave; devoir y penser.</p></li><li class="list__item" id="-23riyj_230"><p id="-23riyj_236"><span class="control" id="-23riyj_237">QCM (D&eacute;pendance)</span>: c) <code class="code" id="-23riyj_238">spring-boot-starter-security</code></p></li><li class="list__item" id="-23riyj_231"><p id="-23riyj_239"><span class="control" id="-23riyj_240">QCM (Comportement par d&eacute;faut)</span>: c) Vous &ecirc;tes redirig&eacute; vers une page de connexion.</p></li><li class="list__item" id="-23riyj_232"><p id="-23riyj_241"><span class="control" id="-23riyj_242">Question ouverte (SecurityFilterChain)</span>: C'est une cha&icirc;ne de filtres Servlet que chaque requ&ecirc;te HTTP doit traverser. Chaque filtre a une responsabilit&eacute; sp&eacute;cifique (g&eacute;rer la session, v&eacute;rifier le token CSRF, g&eacute;rer l'authentification, v&eacute;rifier l'autorisation, etc.). C'est le m&eacute;canisme central par lequel Spring Security intercepte et s&eacute;curise les requ&ecirc;tes.</p></li><li class="list__item" id="-23riyj_233"><p id="-23riyj_243"><span class="control" id="-23riyj_244">QCM (Utilisateur fixe)</span>: c) En ajoutant <code class="code" id="-23riyj_245">spring.security.user.name</code> et <code class="code" id="-23riyj_246">spring.security.user.password</code> dans <code class="code" id="-23riyj_247">application.properties</code>.</p></li></ol></section><section class="chapter"><h3 id="chapitre-3" data-toc="chapitre-3">Chapitre 3</h3><ol class="list _decimal" id="-23riyj_248" type="1"><li class="list__item" id="-23riyj_249"><p id="-23riyj_254"><span class="control" id="-23riyj_255">Question ouverte (Config Java vs Properties)</span>: Le fichier <code class="code" id="-23riyj_256">application.properties</code> est limit&eacute; &agrave; des configurations simples et statiques. Une classe de configuration Java permet une configuration beaucoup plus complexe et dynamique en utilisant la pleine puissance du langage Java : logique conditionnelle, injection de d&eacute;pendances, cr&eacute;ation de beans complexes, etc. C'est la seule fa&ccedil;on de configurer des aspects comme des gestionnaires de succ&egrave;s/&eacute;chec personnalis&eacute;s, des fournisseurs d'authentification, etc.</p></li><li class="list__item" id="-23riyj_250"><p id="-23riyj_257"><span class="control" id="-23riyj_258">QCM (Annotation essentielle)</span>: c) <code class="code" id="-23riyj_259">@EnableWebSecurity</code></p></li><li class="list__item" id="-23riyj_251"><p id="-23riyj_260"><span class="control" id="-23riyj_261">QCM (Token CSRF)</span>: b) Il ajoute le nom du champ attendu par Spring Security pour le token CSRF.</p></li><li class="list__item" id="-23riyj_252"><p id="-23riyj_262"><span class="control" id="-23riyj_263">Question ouverte (BCrypt vs SHA-256)</span>: BCrypt est sup&eacute;rieur car il est <span class="control" id="-23riyj_264">adaptatif</span> et <span class="control" id="-23riyj_265">lent</span>. Il int&egrave;gre un &quot;salt&quot; (sel) al&eacute;atoire &agrave; chaque hachage, ce qui emp&ecirc;che les attaques par table arc-en-ciel. Sa lenteur, configurable via un &quot;work factor&quot;, le rend r&eacute;sistant aux attaques par force brute sur des hardware modernes (GPU). SHA-256 est un algorithme de hachage rapide, non con&ccedil;u pour le stockage de mots de passe, et vuln&eacute;rable sans salage et &quot;stretching&quot; manuels.</p></li><li class="list__item" id="-23riyj_253"><p id="-23riyj_266"><span class="control" id="-23riyj_267">QCM (Bean informations utilisateur)</span>: c) <code class="code" id="-23riyj_268">UserDetailsService</code></p></li></ol></section><section class="chapter"><h3 id="chapitre-4" data-toc="chapitre-4">Chapitre 4</h3><ol class="list _decimal" id="-23riyj_269" type="1"><li class="list__item" id="-23riyj_270"><p id="-23riyj_275"><span class="control" id="-23riyj_276">Question ouverte (S&eacute;curisation URL vs M&eacute;thode)</span>: La s&eacute;curisation par URL (<code class="code" id="-23riyj_277">authorizeHttpRequests</code>) est une premi&egrave;re ligne de d&eacute;fense, globale et facile &agrave; configurer pour des sections enti&egrave;res d'une application (ex: <code class="code" id="-23riyj_278">/admin/**</code>). La s&eacute;curisation par m&eacute;thode (<code class="code" id="-23riyj_279">@PreAuthorize</code>) est plus fine et plus robuste car elle est li&eacute;e &agrave; la logique m&eacute;tier elle-m&ecirc;me, ind&eacute;pendamment de l'URL. On utilise la premi&egrave;re pour les r&egrave;gles g&eacute;n&eacute;rales et la seconde pour les r&egrave;gles m&eacute;tier sp&eacute;cifiques (ex: seul le propri&eacute;taire d'un objet peut le modifier).</p></li><li class="list__item" id="-23riyj_271"><p id="-23riyj_280"><span class="control" id="-23riyj_281">QCM (Annotation <code class="code" id="-23riyj_284">@PreAuthorize</code>)</span>: c) <code class="code" id="-23riyj_282">@EnableGlobalMethodSecurity</code> (ancienne version) ou <code class="code" id="-23riyj_283">@EnableMethodSecurity</code> (nouvelle version)</p></li><li class="list__item" id="-23riyj_272"><p id="-23riyj_285"><span class="control" id="-23riyj_286">QCM (hasRole vs hasAuthority)</span>: b) <code class="code" id="-23riyj_287">hasAuthority('ROLE_MANAGER')</code></p></li><li class="list__item" id="-23riyj_273"><p id="-23riyj_288"><span class="control" id="-23riyj_289">Question ouverte (<code class="code" id="-23riyj_294">@PostAuthorize</code>)</span>: <code class="code" id="-23riyj_290">@PostAuthorize</code> est utile quand la d&eacute;cision d'autorisation d&eacute;pend du <span class="control" id="-23riyj_291">r&eacute;sultat</span> de la m&eacute;thode. Par exemple, une m&eacute;thode <code class="code" id="-23riyj_292">findConfidentialDocument(id)</code> pourrait retourner un document qui contient une liste de lecteurs autoris&eacute;s. L'expression SpEL pourrait &ecirc;tre <code class="code" id="-23riyj_293">@PostAuthorize(&quot;returnObject.authorizedReaders.contains(authentication.name)&quot;)</code>. La v&eacute;rification se fait sur l'objet retourn&eacute;.</p></li><li class="list__item" id="-23riyj_274"><p id="-23riyj_295"><span class="control" id="-23riyj_296">QCM (Nom utilisateur dans SpEL)</span>: d) <code class="code" id="-23riyj_297">authentication.principal.username</code> ou <code class="code" id="-23riyj_298">authentication.name</code></p></li></ol></section><section class="chapter"><h3 id="chapitre-5" data-toc="chapitre-5">Chapitre 5</h3><ol class="list _decimal" id="-23riyj_299" type="1"><li class="list__item" id="-23riyj_300"><p id="-23riyj_305"><span class="control" id="-23riyj_306">Question ouverte (Analogie CSRF)</span>: C'est comme si un d&eacute;marcheur malveillant vous faisait signer un ch&egrave;que en blanc (la requ&ecirc;te forg&eacute;e) et l'envoyait &agrave; votre banque. Votre banque reconna&icirc;t votre signature (le cookie de session) et l'honore. Le &quot;Synchronizer Token Pattern&quot; ajoute un m&eacute;mo secret sur le ch&egrave;que (le token CSRF). Le d&eacute;marcheur ne conna&icirc;t pas le m&eacute;mo du jour, donc la banque refuse le ch&egrave;que.</p></li><li class="list__item" id="-23riyj_301"><p id="-23riyj_307"><span class="control" id="-23riyj_308">QCM (M&eacute;thodes prot&eacute;g&eacute;es par CSRF)</span>: b) POST, PUT, DELETE, PATCH (toutes les m&eacute;thodes qui modifient l'&eacute;tat).</p></li><li class="list__item" id="-23riyj_302"><p id="-23riyj_309"><span class="control" id="-23riyj_310">QCM (CSRF et API stateless)</span>: b) La d&eacute;sactiver car elle n'est pas pertinente dans ce contexte.</p></li><li class="list__item" id="-23riyj_303"><p id="-23riyj_311"><span class="control" id="-23riyj_312">Question ouverte (D&eacute;connexion en POST)</span>: Pour emp&ecirc;cher une attaque CSRF simple. Si la d&eacute;connexion se faisait en GET, un attaquant pourrait mettre un lien <code class="code" id="-23riyj_313">&lt;img src=&quot;http://myapp.com/logout&quot;&gt;</code> sur un site externe. En visitant ce site, votre navigateur ex&eacute;cuterait la requ&ecirc;te GET et vous d&eacute;connecterait &agrave; votre insu. Le POST, prot&eacute;g&eacute; par le token CSRF, emp&ecirc;che cela.</p></li><li class="list__item" id="-23riyj_304"><p id="-23riyj_314"><span class="control" id="-23riyj_315">QCM (Erreur CSRF)</span>: d) 403 Forbidden</p></li></ol></section><section class="chapter"><h3 id="chapitre-6" data-toc="chapitre-6">Chapitre 6</h3><ol class="list _decimal" id="-23riyj_316" type="1"><li class="list__item" id="-23riyj_317"><p id="-23riyj_322"><span class="control" id="-23riyj_323">Question ouverte (<code class="code" id="-23riyj_326">UserDetailsService</code>)</span>: C'est une interface qui sert de pont entre Spring Security et la source de donn&eacute;es des utilisateurs. Son r&ocirc;le est de prendre un <code class="code" id="-23riyj_324">username</code> et de retourner un objet <code class="code" id="-23riyj_325">UserDetails</code> (contenant le mot de passe hach&eacute; et les autorit&eacute;s). C'est le composant cl&eacute; qui permet de d&eacute;coupler Spring Security de la mani&egrave;re dont les utilisateurs sont stock&eacute;s (JPA, LDAP, fichier, etc.).</p></li><li class="list__item" id="-23riyj_318"><p id="-23riyj_327"><span class="control" id="-23riyj_328">QCM (Exception utilisateur non trouv&eacute;)</span>: c) <code class="code" id="-23riyj_329">UsernameNotFoundException</code></p></li><li class="list__item" id="-23riyj_319"><p id="-23riyj_330"><span class="control" id="-23riyj_331">QCM (D&eacute;tection du service)</span>: c) Gr&acirc;ce &agrave; l'injection de d&eacute;pendances, il cherche un bean de type <code class="code" id="-23riyj_332">UserDetailsService</code> dans le contexte de l'application.</p></li><li class="list__item" id="-23riyj_320"><p id="-23riyj_333"><span class="control" id="-23riyj_334">Question ouverte (PasswordEncoder et DataSeeder)</span>: On ne stocke jamais de mot de passe en clair car si la base est compromise, ils sont tous vol&eacute;s. Le <code class="code" id="-23riyj_335">PasswordEncoder</code> (via BCrypt) transforme le mot de passe en un hachage irr&eacute;versible et sal&eacute;. Le <code class="code" id="-23riyj_336">DataSeeder</code> travaille avec lui en s'assurant que lorsqu'on ins&egrave;re des utilisateurs de test, leurs mots de passe sont d'abord pass&eacute;s par la m&eacute;thode <code class="code" id="-23riyj_337">encode()</code> du <code class="code" id="-23riyj_338">PasswordEncoder</code> avant d'&ecirc;tre sauvegard&eacute;s, garantissant qu'aucun mot de passe en clair n'est jamais &eacute;crit en base.</p></li><li class="list__item" id="-23riyj_321"><p id="-23riyj_339"><span class="control" id="-23riyj_340">QCM (Ex&eacute;cution au d&eacute;marrage)</span>: a) <code class="code" id="-23riyj_341">ApplicationRunner</code> ou <code class="code" id="-23riyj_342">CommandLineRunner</code></p></li></ol></section><section class="chapter"><h3 id="chapitre-7" data-toc="chapitre-7">Chapitre 7</h3><ol class="list _decimal" id="-23riyj_343" type="1"><li class="list__item" id="-23riyj_344"><p id="-23riyj_349"><span class="control" id="-23riyj_350">Question ouverte (AuthenticationManager vs Provider)</span>: L' <code class="code" id="-23riyj_351">AuthenticationManager</code> est le chef d'orchestre. Il ne fait pas le travail lui-m&ecirc;me. Il re&ccedil;oit une tentative d'authentification (<code class="code" id="-23riyj_352">Authentication</code>) et la d&eacute;l&egrave;gue &agrave; sa liste d' <code class="code" id="-23riyj_353">AuthenticationProvider</code>. Chaque <code class="code" id="-23riyj_354">Provider</code> est un sp&eacute;cialiste qui sait comment g&eacute;rer un type d'authentification. Le manager les interroge un par un jusqu'&agrave; ce que l'un d'eux r&eacute;ussisse ou que tous aient &eacute;chou&eacute;.</p></li><li class="list__item" id="-23riyj_345"><p id="-23riyj_355"><span class="control" id="-23riyj_356">QCM (R&ocirc;le de <code class="code" id="-23riyj_358">supports()</code>)</span>: b) Indiquer si ce provider est capable de g&eacute;rer le type d'objet <code class="code" id="-23riyj_357">Authentication</code> fourni.</p></li><li class="list__item" id="-23riyj_346"><p id="-23riyj_359"><span class="control" id="-23riyj_360">QCM (Redirection au succ&egrave;s)</span>: a) Un <code class="code" id="-23riyj_361">AuthenticationSuccessHandler</code></p></li><li class="list__item" id="-23riyj_347"><p id="-23riyj_362"><span class="control" id="-23riyj_363">Question ouverte (Provider vs UserDetailsService)</span>: Surcharger le <code class="code" id="-23riyj_364">UserDetailsService</code> ne permet que de changer <span class="emphasis" id="-23riyj_365">d'o&ugrave;</span> viennent les donn&eacute;es de l'utilisateur. Cr&eacute;er un <code class="code" id="-23riyj_366">AuthenticationProvider</code> permet de changer <span class="emphasis" id="-23riyj_367">comment</span> l'authentification est v&eacute;rifi&eacute;e. On peut y ajouter des logiques complexes (v&eacute;rification d'un code PIN, d'une heure de connexion, d'une adresse IP, etc.) qui vont bien au-del&agrave; de la simple comparaison de mot de passe.</p></li><li class="list__item" id="-23riyj_348"><p id="-23riyj_368"><span class="control" id="-23riyj_369">QCM (Provider avec <code class="code" id="-23riyj_370">@Component</code>)</span>: c) Il sera ajout&eacute; &agrave; la liste des providers et sera probablement essay&eacute; avant celui par d&eacute;faut.</p></li></ol></section><section class="chapter"><h3 id="chapitre-8" data-toc="chapitre-8">Chapitre 8</h3><ol class="list _decimal" id="-23riyj_371" type="1"><li class="list__item" id="-23riyj_372"><p id="-23riyj_377"><span class="control" id="-23riyj_378">Question ouverte (Stateful vs Stateless)</span>: Stateful (session) : le serveur stocke des informations sur l'utilisateur connect&eacute; dans sa m&eacute;moire ou une base de donn&eacute;es, et le client envoie un simple identifiant de session (cookie). Stateless (JWT) : le serveur ne stocke rien. Le client envoie un token auto-contenu (le JWT) qui contient toutes les informations d'authentification et d'autorisation. Le stateless est pr&eacute;f&eacute;r&eacute; pour les microservices car n'importe quel service peut valider le token sans avoir besoin d'un &eacute;tat partag&eacute;, ce qui facilite grandement la scalabilit&eacute; horizontale.</p></li><li class="list__item" id="-23riyj_373"><p id="-23riyj_379"><span class="control" id="-23riyj_380">QCM (Int&eacute;grit&eacute; JWT)</span>: d) La Signature</p></li><li class="list__item" id="-23riyj_374"><p id="-23riyj_381"><span class="control" id="-23riyj_382">QCM (Politique de session pour JWT)</span>: c) <code class="code" id="-23riyj_383">SessionCreationPolicy.STATELESS</code></p></li><li class="list__item" id="-23riyj_375"><p id="-23riyj_384"><span class="control" id="-23riyj_385">Question ouverte (<code class="code" id="-23riyj_392">JwtAuthFilter</code>)</span>: Il s'ex&eacute;cute &agrave; chaque requ&ecirc;te. Il v&eacute;rifie la pr&eacute;sence de l'en-t&ecirc;te <code class="code" id="-23riyj_386">Authorization: Bearer ...</code>. Si pr&eacute;sent, il extrait le token, le valide (signature, expiration) en utilisant le <code class="code" id="-23riyj_387">JwtService</code>, en extrait le nom d'utilisateur, charge les <code class="code" id="-23riyj_388">UserDetails</code> correspondants via le <code class="code" id="-23riyj_389">UserDetailsService</code>, et si tout est valide, il cr&eacute;e un objet <code class="code" id="-23riyj_390">Authentication</code> et le place dans le <code class="code" id="-23riyj_391">SecurityContextHolder</code>, authentifiant ainsi l'utilisateur pour la dur&eacute;e de la requ&ecirc;te.</p></li><li class="list__item" id="-23riyj_376"><p id="-23riyj_393"><span class="control" id="-23riyj_394">QCM (O&ugrave; placer le JWT)</span>: c) Dans l'en-t&ecirc;te <code class="code" id="-23riyj_395">Authorization</code> avec le pr&eacute;fixe <code class="code" id="-23riyj_396">Bearer</code>.</p></li></ol></section><section class="chapter"><h3 id="chapitre-9" data-toc="chapitre-9">Chapitre 9</h3><ol class="list _decimal" id="-23riyj_397" type="1"><li class="list__item" id="-23riyj_399"><p id="-23riyj_404"><span class="control" id="-23riyj_405">Question ouverte (OAuth 2.0 vs OIDC)</span>: OAuth 2.0 est un protocole d' <span class="control" id="-23riyj_406">autorisation</span> (il permet de d&eacute;l&eacute;guer l'acc&egrave;s &agrave; des ressources). OIDC (OpenID Connect) est une fine surcouche d'OAuth 2.0 qui ajoute la brique d' <span class="control" id="-23riyj_407">authentification</span>. OIDC standardise la fa&ccedil;on d'obtenir des informations sur l'utilisateur (via un <code class="code" id="-23riyj_408">ID Token</code>) et de v&eacute;rifier son identit&eacute;, r&eacute;pondant &agrave; la question &quot;Qui est cet utilisateur ?&quot;.</p></li><li class="list__item" id="-23riyj_400"><p id="-23riyj_409"><span class="control" id="-23riyj_410">QCM (Flux Authorization Code)</span>: c) Un code d'autorisation &agrave; usage unique.</p></li><li class="list__item" id="-23riyj_401"><p id="-23riyj_411"><span class="control" id="-23riyj_412">QCM (Configuration Google)</span>: b) Ajouter les d&eacute;pendances et fournir le client-id et le client-secret de Google dans <code class="code" id="-23riyj_413">application.properties</code>.</p></li><li class="list__item" id="-23riyj_402"><p id="-23riyj_414"><span class="control" id="-23riyj_415">Question ouverte (Scope)</span>: Un &quot;scope&quot; est une permission que le Client demande au nom de l'utilisateur. Il permet de limiter l'acc&egrave;s du client au strict n&eacute;cessaire (principe de moindre privil&egrave;ge). Exemple : une application de calendrier pourrait demander le scope <code class="code" id="-23riyj_416">calendar.readonly</code> pour lire les &eacute;v&eacute;nements, mais pas <code class="code" id="-23riyj_417">calendar.write</code> pour les modifier. L'utilisateur voit ces scopes sur la page de consentement et peut les approuver ou les refuser.</p></li><li class="list__item" id="-23riyj_403"><p id="-23riyj_418"><span class="control" id="-23riyj_419">QCM (Annotation raccourci)</span>: c) <code class="code" id="-23riyj_420">@AuthenticationPrincipal</code></p></li></ol><p id="-23riyj_398">{/collapsible}</p></section></div></div></section><div class="last-modified">15 juin 2025</div><div data-feedback-placeholder="true"></div><div class="navigation-links _bottom"><a href="008-00-jwt.html" class="navigation-links__prev">Module 2 / Chapitre 8 : Authentification via JWT (JSON Web Tokens)</a></div></article><div id="disqus_thread"></div></div></section></main></div><script src="https://resources.jetbrains.com/writerside/apidoc/6.22.0-b776/app.js"></script></body></html>