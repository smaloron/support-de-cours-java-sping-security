# Module 2 / Chapitre 8 : Authentification via JWT (JSON Web Tokens)

## L'essentiel

### Objectifs pédagogiques

À la fin de ce chapitre, vous serez capable de :

* **Expliquer** ce qu'est un JWT, sa structure et ses avantages pour les API REST.
* **Distinguer** l'authentification "stateful" (basée sur session) et "stateless" (basée sur token).
* **Mettre en place** un endpoint pour générer un token JWT lors de la connexion.
* **Créer** un filtre personnalisé pour valider les tokens JWT à chaque requête.
* **Configurer** Spring Security pour qu'il fonctionne en mode stateless avec JWT.

### Introduction : Le Billet de Concert à la Place du Tampon sur la Main

Imaginez que vous allez à un festival de musique qui dure toute une journée.

* **L'approche "Stateful" (avec session)** : À l'entrée, on vous met un tampon sur la main. Pour aller d'une scène à l'
  autre, chaque agent de sécurité doit regarder votre tampon. Le festival doit gérer la liste des tampons valides, leur
  couleur, etc. Si vous perdez le tampon (effacé par l'eau), vous devez retourner à l'entrée principale. C'est l'
  authentification par session : le serveur "se souvient" de vous (le tampon) et doit maintenir cet état.

* **L'approche "Stateless" (avec JWT)** : À l'entrée, on vous donne un billet de concert (un badge) infalsifiable. Ce
  billet contient toutes les informations nécessaires : votre nom, les zones auxquelles vous avez accès (VIP,
  backstage), et une date d'expiration. Pour aller d'une scène à l'autre, l'agent de sécurité n'a qu'à regarder votre
  billet. Il n'a pas besoin de contacter l'entrée principale ou de consulter une liste. Le billet est auto-suffisant.
  C'est l'authentification par JWT : le client détient une preuve d'identité auto-contenue et vérifiable.

Les JWT sont les "billets de concert" du monde des API. Ils permettent une communication sécurisée sans que le serveur
ait besoin de stocker l'état de la session de chaque utilisateur, ce qui est idéal pour les architectures distribuées et
les microservices.

### Qu'est-ce qu'un JWT ?

Un JWT (prononcé "jot") est une chaîne de caractères compacte et sécurisée, définie par la
norme [RFC 7519](https://tools.ietf.org/html/rfc7519). Elle se compose de trois parties, séparées par des points (`.`).

`eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c`

1. **Header (En-tête)** : Contient les métadonnées du token (l'algorithme de signature, le type de token). C'est du JSON
   encodé en Base64Url.
   `{"alg": "HS256", "typ": "JWT"}` -> `eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9`

2. **Payload (Charge utile)** : Contient les "claims" (revendications), c'est-à-dire les informations sur l'
   utilisateur (son ID, son nom, ses rôles) et des métadonnées (date d'émission, date d'expiration). C'est aussi du JSON
   encodé en Base64Url.
   `{"sub": "john.doe", "roles": ["ROLE_USER"], "iat": 1616239022, "exp": 1616325422}`

3. **Signature** : C'est la partie la plus importante pour la sécurité. Elle est créée en prenant le header encodé, le
   payload encodé, une **clé secrète** (connue uniquement du serveur), et en les passant dans l'algorithme de signature
   spécifié dans le header.
   `HMACSHA256(base64UrlEncode(header) + "." + base64UrlEncode(payload), secret)`

**Comment ça sécurise ?**
Si un attaquant modifie le payload (par exemple, en s'ajoutant le rôle `ROLE_ADMIN`), la signature ne correspondra plus.
Le serveur, en recalculant la signature avec la clé secrète, détectera immédiatement la falsification et rejettera le
token.

### Le flux d'authentification JWT

1. L'utilisateur s'authentifie une première fois avec ses identifiants (login/mot de passe) sur un endpoint dédié (ex:
   `/api/login`).
2. Le serveur valide les identifiants. S'ils sont corrects, il génère un JWT, signé avec sa clé secrète, et le renvoie
   au client.
3. Le client (navigateur, application mobile) stocke ce JWT (dans le `localStorage`, `sessionStorage` ou une variable).
4. Pour chaque requête suivante vers une ressource protégée, le client inclut le JWT dans l'en-tête HTTP `Authorization`
   avec le préfixe `Bearer`.
   `Authorization: Bearer <token_jwt>`
5. Le serveur reçoit la requête, extrait le token de l'en-tête, vérifie sa signature et sa date d'expiration. Si tout
   est valide, il fait confiance aux informations du payload (rôles, etc.) et autorise l'accès.

### Implémentation avec Spring Security

Pour implémenter JWT, nous devons changer notre approche. Fini `formLogin()`. Nous allons créer nos propres composants.

**Étape 1 : Ajouter la dépendance pour JWT**

Nous utiliserons la bibliothèque `jjwt`, très populaire et complète.
Ajoutez ceci à votre `pom.xml` :

```xml

<dependency>
    <groupId>io.jsonwebtoken</groupId>
    <artifactId>jjwt-api</artifactId>
    <version>0.12.5</version>
</dependency>
<dependency>
<groupId>io.jsonwebtoken</groupId>
<artifactId>jjwt-impl</artifactId>
<version>0.12.5</version>
<scope>runtime</scope>
</dependency>
<dependency>
<groupId>io.jsonwebtoken</groupId>
<artifactId>jjwt-jackson</artifactId>
<version>0.12.5</version>
<scope>runtime</scope>
</dependency>
```

**Étape 2 : Un service pour gérer les JWT (création et validation)**

**`fr/formation/spring/taskmaster/security/JwtService.java`**

```java
package fr.formation.spring.taskmaster.security;

import io.jsonwebtoken.Claims;
import io.jsonwebtoken.Jwts;
import io.jsonwebtoken.security.Keys;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.security.core.GrantedAuthority;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.stereotype.Service;

import javax.crypto.SecretKey;
import java.util.Date;
import java.util.function.Function;
import java.util.stream.Collectors;

@Service
public class JwtService {

    @Value("${application.jwt.secretKey}")
    private String secretKeyString;

    @Value("${application.jwt.expiration}")
    private long jwtExpiration;

    // Génère le token
    public String generateToken(UserDetails userDetails) {
        SecretKey key = getSignInKey();
        return Jwts.builder()
                .subject(userDetails.getUsername())
                .claim("authorities", userDetails.getAuthorities().stream()
                        .map(GrantedAuthority::getAuthority)
                        .collect(Collectors.toList()))
                .issuedAt(new Date(System.currentTimeMillis()))
                .expiration(new Date(System.currentTimeMillis() + jwtExpiration))
                .signWith(key)
                .compact();
    }

    // Extrait toutes les informations (claims) du token
    private Claims extractAllClaims(String token) {
        return Jwts.parser()
                .verifyWith(getSignInKey())
                .build()
                .parseSignedClaims(token)
                .getPayload();
    }

    // Extrait une information spécifique
    public <T> T extractClaim(String token, Function<Claims, T> claimsResolver) {
        final Claims claims = extractAllClaims(token);
        return claimsResolver.apply(claims);
    }

    public String extractUsername(String token) {
        return extractClaim(token, Claims::getSubject);
    }

    // Valide le token
    public boolean isTokenValid(String token, UserDetails userDetails) {
        final String username = extractUsername(token);
        return (username.equals(userDetails.getUsername())) && !isTokenExpired(token);
    }

    private boolean isTokenExpired(String token) {
        return extractExpiration(token).before(new Date());
    }

    private Date extractExpiration(String token) {
        return extractClaim(token, Claims::getExpiration);
    }

    // Construit la clé secrète
    private SecretKey getSignInKey() {
        byte[] keyBytes = secretKeyString.getBytes();
        return Keys.hmacShaKeyFor(keyBytes);
    }
}
```

N'oubliez pas d'ajouter les propriétés dans `application.properties` :

```properties
# Clé secrète pour signer les JWT. DOIT être longue et complexe en prod.
# Pour la générer : new SecureRandom().generateSeed(64) puis l'encoder en Base64.
application.jwt.secretKey=MaSuperCleSecreteDePlusDe256BitsPourEtreEnSecurite123456
# Durée de validité du token en millisecondes (ici 24h)
application.jwt.expiration=86400000
```

<warning>
La clé secrète est la clé du royaume. Ne la stockez jamais en clair dans le code ou dans un `pom.xml`. Utilisez les variables d'environnement ou un gestionnaire de secrets (comme Vault) en production.
</warning>

**Étape 3 : Le filtre de validation JWT**

Ce filtre s'exécutera à chaque requête. Son rôle est de vérifier la présence d'un token JWT, de le valider et de mettre
à jour le contexte de sécurité.

**`fr/formation/spring/taskmaster/security/JwtAuthFilter.java`**

```java
package fr.formation.spring.taskmaster.security;

import jakarta.servlet.FilterChain;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import org.springframework.lang.NonNull;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.web.authentication.WebAuthenticationDetailsSource;
import org.springframework.stereotype.Component;
import org.springframework.web.filter.OncePerRequestFilter;

import java.io.IOException;

@Component
public class JwtAuthFilter extends OncePerRequestFilter {

    private final JwtService jwtService;
    private final UserDetailsService userDetailsService;

    // ... constructeur ...

    @Override
    protected void doFilterInternal(
            @NonNull HttpServletRequest request,
            @NonNull HttpServletResponse response,
            @NonNull FilterChain filterChain
    ) throws ServletException, IOException {
        final String authHeader = request.getHeader("Authorization");
        if (authHeader == null || !authHeader.startsWith("Bearer ")) {
            filterChain.doFilter(request, response); // Passe au filtre suivant
            return;
        }

        final String jwt = authHeader.substring(7);
        final String username = jwtService.extractUsername(jwt);

        if (username != null && SecurityContextHolder.getContext().getAuthentication() == null) {
            UserDetails userDetails = this.userDetailsService.loadUserByUsername(username);
            if (jwtService.isTokenValid(jwt, userDetails)) {
                // Si le token est valide, on crée un objet Authentication
                UsernamePasswordAuthenticationToken authToken = new UsernamePasswordAuthenticationToken(
                        userDetails,
                        null, // Pas de mot de passe ici
                        userDetails.getAuthorities()
                );
                authToken.setDetails(new WebAuthenticationDetailsSource().buildDetails(request));
                // Et on le met dans le contexte de sécurité
                SecurityContextHolder.getContext().setAuthentication(authToken);
            }
        }
        filterChain.doFilter(request, response);
    }
}
```

**Étape 4 : Adapter `SecurityConfig` pour le mode "stateless"**

C'est le changement le plus important. On désactive `formLogin`, `csrf` et on dit à Spring de ne pas créer de session.

```java
package fr.formation.spring.taskmaster.config;

import fr.formation.spring.taskmaster.security.JwtAuthFilter;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.authentication.AuthenticationProvider;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.http.SessionCreationPolicy;
import org.springframework.security.web.SecurityFilterChain;
import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;

@Configuration
// ...
public class SecurityConfig {
    private final JwtAuthFilter jwtAuthFilter;
    private final AuthenticationProvider authenticationProvider; // Notre provider custom si besoin

    // ... constructeur ...

    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
        http
                .csrf(csrf -> csrf.disable()) // CSRF n'est pas utile pour les API stateless
                .authorizeHttpRequests(auth -> auth
                        // Notre endpoint de login est public
                        .requestMatchers("/api/auth/**").permitAll()
                        .anyRequest().authenticated()
                )
                .sessionManagement(session -> session
                        // On demande à Spring de ne plus gérer les sessions
                        .sessionCreationPolicy(SessionCreationPolicy.STATELESS)
                )
                // On peut garder notre provider custom ou utiliser celui par défaut
                .authenticationProvider(authenticationProvider)
                // On ajoute notre filtre JWT AVANT le filtre de login/password standard
                .addFilterBefore(jwtAuthFilter, UsernamePasswordAuthenticationFilter.class);

        return http.build();
    }

    // ... reste de la config (PasswordEncoder, etc.)
}
```

**Étape 5 : Créer un contrôleur pour l'authentification**

Puisque nous n'avons plus `formLogin`, nous devons créer notre propre endpoint pour que les utilisateurs obtiennent un
token.

**`fr/formation/spring/taskmaster/controller/AuthController.java`**

```java
package fr.formation.spring.taskmaster.controller;

import fr.formation.spring.taskmaster.dto.AuthRequest;
import fr.formation.spring.taskmaster.dto.AuthResponse;
import fr.formation.spring.taskmaster.security.JwtService;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
@RequestMapping("/api/auth")
public class AuthController {

    private final AuthenticationManager authenticationManager;
    private final JwtService jwtService;

    // ... constructeur ...

    // Il faut exposer l'AuthenticationManager en tant que bean
    // dans SecurityConfig pour pouvoir l'injecter ici.

    @PostMapping("/login")
    public AuthResponse authenticateAndGetToken(@RequestBody AuthRequest authRequest) {
        // On demande à Spring de vérifier les identifiants
        Authentication authentication = authenticationManager.authenticate(
                new UsernamePasswordAuthenticationToken(
                        authRequest.getUsername(),
                        authRequest.getPassword()
                )
        );

        // Si on arrive ici, l'authentification a réussi
        UserDetails userDetails = (UserDetails) authentication.getPrincipal();
        String jwtToken = jwtService.generateToken(userDetails);

        return new AuthResponse(jwtToken);
    }
}
```

Créez les DTOs `AuthRequest` (String username, String password) et `AuthResponse` (String token).

Pour que cela fonctionne, il faut exposer le bean `AuthenticationManager` :
**Dans `SecurityConfig.java`:**

```java
// ...

import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.config.annotation.authentication.configuration.AuthenticationConfiguration;

@Bean
public AuthenticationManager authenticationManager(
        AuthenticationConfiguration config) throws Exception {
    return config.getAuthenticationManager();
}
```

---

## Exercice 9 : Migration de TaskMaster vers une API REST avec JWT

<procedure title="Passage à une authentification stateless avec JWT" id="exercice-2-3">
    <p>
    L'objectif est de transformer l'authentification de <strong>TaskMaster</strong>, actuellement basée sur des sessions et des formulaires, en une authentification stateless pour une API REST en utilisant des JWT.
    </p>
    <ol>
        <li>Ajoutez les dépendances `jjwt` à votre `pom.xml`.</li>
        <li>Créez le <code>JwtService</code>. Ajoutez la clé secrète et la durée d'expiration dans <code>application.properties</code>.</li>
        <li>Créez le filtre <code>JwtAuthFilter</code> qui interceptera et validera les tokens.</li>
        <li>Modifiez radicalement votre <code>SecurityConfig</code> :
            <ul>
                <li>Désactivez CSRF et <code>formLogin</code>.</li>
                <li>Configurez la gestion des sessions en <code>STATELESS</code>.</li>
                <li>Ajoutez votre <code>JwtAuthFilter</code> dans la chaîne de filtres.</li>
                <li>Autorisez l'accès public à un nouvel endpoint <code>/api/auth/login</code>.</li>
                <li>Exposez le bean <code>AuthenticationManager</code>.</li>
            </ul>
        </li>
        <li>Créez l'<code>AuthController</code> avec un endpoint POST <code>/api/auth/login</code> qui prend un nom d'utilisateur et un mot de passe, et renvoie un JWT en cas de succès.</li>
        <li>Utilisez un client API (comme Postman, Insomnia ou `curl`) pour tester le flux :
            <ol>
                <li>Faites une requête POST vers <code>/api/auth/login</code> avec les identifiants de <code>john.doe</code>. Vous devriez recevoir un token JWT.</li>
                <li>Copiez ce token.</li>
                <li>Faites une requête GET vers un endpoint protégé (ex: <code>/api/projects</code>) en ajoutant l'en-tête <code>Authorization: Bearer VOTRE_TOKEN_ICI</code>. Vous devriez obtenir une réponse 200 OK.</li>
                <li>Essayez d'accéder à la même ressource sans l'en-tête, ou avec un token invalide. Vous devriez recevoir une erreur 401 ou 403.</li>
            </ol>
        </li>
    </ol>
</procedure>

### Correction exercice 9 {collapsible="true"}

<p>Le code nécessaire pour compléter cet exercice est celui présenté dans les sections ci-dessus. Voici un résumé des points clés et des pièges à éviter :</p>
<ul>
    <li>
        <strong>Dépendances :</strong> Assurez-vous d'avoir les 3 dépendances <code>jjwt</code> (api, impl, jackson).
    </li>
    <li>
        <strong>Clé secrète :</strong> La clé dans <code>application.properties</code> doit être suffisamment longue pour l'algorithme HS256 (256 bits / 8 = 32 octets/caractères minimum). Si elle est trop courte, vous aurez une exception au démarrage.
    </li>
    <li>
        <strong>Configuration de sécurité :</strong> C'est le plus grand changement. Il faut bien penser à :
        <ul>
            <li><code>.csrf(csrf -> csrf.disable())</code></li>
            <li><code>.sessionManagement(session -> session.sessionCreationPolicy(SessionCreationPolicy.STATELESS))</code></li>
            <li>Ne plus avoir de <code>.formLogin()</code> ni de <code>.logout()</code> standard.</li>
            <li>Ajouter le filtre : <code>.addFilterBefore(jwtAuthFilter, UsernamePasswordAuthenticationFilter.class)</code></li>
        </ul>
    </li>
    <li>
        <strong>Exposition de l'AuthenticationManager :</strong> Ne pas oublier le bean `public AuthenticationManager authenticationManager(...)` dans `SecurityConfig`, sinon vous ne pourrez pas l'injecter dans votre `AuthController`.
    </li>
    <li>
        <strong>Tests avec un client API :</strong>
        <ol>
            <li><strong>Login (POST `http://localhost:8080/api/auth/login`)</strong><br>
                Body (raw, JSON):
                <pre><code>{
    "username": "john.doe",
    "password": "pass1"
}</code></pre>
                Réponse (200 OK):
                <pre><code>{
    "token": "eyJhbGciOiJIUzI1NiJ9.eyJzdWIiOiJqb..."
}</code></pre>
            </li>
            <li><strong>Accès à une ressource protégée (GET `http://localhost:8080/api/projects`)</strong><br>
                Headers:
                <pre><code>Authorization: Bearer eyJhbGciOiJIUzI1NiJ9.eyJzdWIiOiJqb...</code></pre>
                Réponse : 200 OK avec les données des projets.
            </li>
        </ol>
    </li>
</ul>

### Auto-évaluation

1. **Question ouverte :** Expliquez la différence fondamentale entre l'authentification stateful (session) et
   stateless (JWT) et pourquoi cette dernière est généralement préférée pour les microservices.
2. **QCM :** Quelle partie d'un JWT garantit son intégrité (qu'il n'a pas été modifié) ?
    * a) Le Header
    * b) Le Payload
    * c) L'encodage Base64Url
    * d) La Signature
3. **QCM :** Pour une API REST stateless sécurisée par JWT, quelle doit être la politique de création de session dans
   Spring Security ?
    * a) `SessionCreationPolicy.IF_REQUIRED`
    * b) `SessionCreationPolicy.ALWAYS`
    * c) `SessionCreationPolicy.STATELESS`
    * d) `SessionCreationPolicy.NEVER`
4. **Question ouverte :** Quel est le rôle du filtre `JwtAuthFilter` dans l'architecture que nous avons mise en place ?
   Décrivez les étapes qu'il exécute.
5. **QCM :** Où un client doit-il placer le JWT pour s'authentifier auprès d'une API protégée ?
    * a) Dans un cookie nommé `JWT_TOKEN`.
    * b) Dans le corps de la requête POST.
    * c) Dans l'en-tête `Authorization` avec le préfixe `Bearer `.
    * d) En tant que paramètre de requête URL `?token=...`.

### Conclusion

Vous venez de franchir une étape majeure dans la sécurisation des applications modernes. La maîtrise de
l'authentification par JWT est une compétence extrêmement recherchée et essentielle pour tout développeur travaillant
sur des API REST, des microservices ou des applications mobiles.

Vous savez désormais :

* Ce qu'est un JWT et comment il fonctionne.
* Comment générer des tokens sécurisés et les valider.
* Comment configurer Spring Security pour un fonctionnement entièrement stateless.
* Comment construire un filtre personnalisé pour intégrer JWT dans la chaîne de sécurité.

Votre boîte à outils de sécurité est maintenant bien plus complète. Vous êtes capable de sécuriser aussi bien une
application web monolithique traditionnelle qu'une API REST moderne.

Le dernier chapitre de ce module nous emmènera encore plus loin dans la modernité en explorant comment déléguer
l'authentification à des fournisseurs externes comme Google ou GitHub, grâce aux protocoles **OAuth 2.0** et **OpenID
Connect**.